<jittershader name="slidescan">
	<description>
	Voronoi
	</description>
	<param name="time" type="float" default="0.0" />
	<param name="bands" type="float" default="7." />
	<param name="rollRate" type="float" default="0.5" />
	<param name="rollAmount" type="float" default="7." />	
	<language name="glsl" version="2.1">
		<bind param="time" program="fp" />
		<bind param="bands" program="fp" />
		<bind param="rollRate" program="fp" />
		<bind param="rollAmount" program="fp" />
		<program name="vp" type="vertex" source="sh.passthrudim.vp.glsl" />
		<program name="fp" type="fragment">
<![CDATA[

//adapted from a shader found here: https://github.com/genekogan/Processing-Shader-Examples/blob/master/TextureShaders/data/pixelrolls.glsl

uniform sampler2DRect tex0;
varying vec2 texcoord0;
varying vec2 texdim0;

uniform float time;
uniform float bands;
uniform float rollRate;
uniform float rollAmount;

void main()
{
	// get uv coordinates
	vec2 uv = texcoord0/texdim0;
	
	// subtract from uv.x the distance we are in the band...
	// this is actually what creates the bands

	// this skews the bands internally... 
		// uv.x -= mod(uv.x, 1.0 / bands)*0.999;		
	// (multiplying or dividing the modulus will distort each individual x pos)
	
	uv.x -= mod(uv.x, 1.0 / bands)*0.9995;
	
	// modulate the y axis
	// mod(position * modulating_roll,1.0)
	// I think 1.0 at the end actually allows it to wrap properly. yep.
	// trying manipulating x or y
	uv.x = mod(uv.y + rollAmount * sin(rollRate * time * uv.x), 1.0);		
	
	// get the color (and convert coords BACK from uv)
	vec4 color = texture2DRect(tex0, uv*texdim0);
	gl_FragColor = color;
}

]]>
		</program>
	</language>
</jittershader>
